#include <linux/module.h>
#include <linux/version.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <linux/vmalloc.h>
#include <linux/blkdev.h>

#include <linux/unistd.h>
//#include <linux/stdio.h>
#include <linux/fcntl.h>
#include <linux/string.h>

static int sampleblk_major;
#define SAMPLEBLK_MINOR	1
static int sampleblk_sect_size = 512;
static int sampleblk_nsects = 10* 1024;

struct sampleblk_dev {
	int minor;
	spinlock_t lock;
	struct request_queue *queue;
	struct gendisk *disk;
	ssize_t size;
	void *data;
};

struct sampleblk_dev *sampleblk_dev = NULL;

// net package

#define MAX_NETPACK_SIZE = 1024 * 10
#define RETURN_CODE = 1024
#define RETURN_DATA = 1025
struct NetDatHeader
{
	int32_t data_type_;
	int32_t data_size_;
};

struct IoChunkStream
{
	NetDataHeader header_;
	size_t chunk_size_;
	void   chunk_data_[0];
};

struct ReturnCode
{
	NetDataHeader header_;
	int32_t code_;
};
//
//NetDataHeader* TcpDataSplit(const char* szRecNetData, int nRecSize)
//{
//	/**
//	    对于szLastSaveData, nRemainSize,为了简单，本例子只
//		作为静态变量使用，因此只限于一个socket的数据接收，
//		假如要同时处理多个socket数据，请放在对应容器里保存
//	*/
//	static char szLastSaveData[MAX_NETPACK_SIZE];
//	static int nRemainSize = 0;
//	static int bFirst = 1;
//
//	if (bFirst)
//	{
//		memset(szLastSaveData, 0, sizeof(szLastSaveData));
//		bFirst = false;
//	}
//
//	/* 本次接收到的数据拼接到上次数据 */
//	memcpy( (char*)(szLastSaveData+nRemainSize), szRecNetData, nRecSize );
//	nRemainSize = nRecSize + nRemainSize;
//
//	/* 强制转换成NetDataPack指针 */
//	NetDataHeader* pDataHead = (NetDataHeader*)szLastSaveData;
//
//	/**
//	   核心算法 
//	*/
//	while ( nRemainSize >sizeof(NetDataHeader_t) &&
//				nRemainSize >= pDataHead->data_size_ +sizeof(NetDataHeader) )
//	{
//			return pDataHead;
//			int  nRecObjectSize = sizeof(NetDataHeader) + pDataHead->data_size_;		//本次收到对象的大小
//			nRemainSize -= nRecObjectSize ;				
//			pDataHead = (NetDataHeader*)( (char*)pDataHead + nRecObjectSize );		//移动下一个对象头
//	}
//	
//	/* 余下数据未能组成一个对象，先保存起来 */
//	if (szLastSaveData != (char*)pDataHead)
//	{
//		memmove(szLastSaveData, (char*)pDataHead, nRemainSize);
//		memset( (char*)( szLastSaveData+nRemainSize), 0, sizeof(szLastSaveData)-nRemainSize );
//	}
//	
//	return true;
//}
//*/
//
///**
//    处理整理好的对象。
//*/
//
//int HandleNetPack(NetDataHeader* pDataHeader)
//{
//	//处理数据包
//	if  (pDataHeader->data_type == RETURN_CODE)
//	{
//		ReturnCode* code = (ReturnCode*)pDataHeader;
//	}
//	else if (pDataHeader->nDataType == RETURN_DATA)
//	{
//		
//	}
//
//	return 1;
//}
//

/*
 *  * Do an I/O operation for each segment
 *   */
static int sampleblk_handle_io(struct sampleblk_dev *sampleblk_dev,
		uint64_t pos, ssize_t size, void *buffer, int write)
{
	if (write)
		{
	//		memcpy(sampleblk_dev->data + pos, buffer, size);
			struct file *fpr;
			mm_segment_t fsr;
			fpr = filp_open("/root/self/client/exam/storage", O_RDWR, 0777);
			if(IS_ERR(fpr))
			{
				printk("create file error\n");
				return -1;
			}
			fsr = get_fs();
			set_fs(KERNEL_DS);
			vfs_write(fpr, buffer, size, &pos);
			filp_close(fpr, NULL);
			set_fs(fsr);

		}
	else
		{
			//memcpy(buffer, sampleblk_dev->data + pos, size);
 		struct file *fpw;
           mm_segment_t fsw;
 		fpw = filp_open("/root/self/client/exam/storage", O_RDWR, 0777);
 		if(IS_ERR(fpw))
 		{
 			printk("create file error\n");
 			return -1;
 		}
 		fsw = get_fs();
 		set_fs(KERNEL_DS);
 		vfs_read(fpw, buffer, size, &pos);
 		filp_close(fpw, NULL);
 		set_fs(fsw);

		}
	return 0;
}

static void sampleblk_request(struct request_queue *q)
{
	struct request *rq = NULL;
	int rv = 0;
	uint64_t
	 pos = 0;
	ssize_t size = 0;
	struct bio_vec* bvec;
	struct req_iterator iter;
	void *kaddr = NULL;

	while ((rq = blk_fetch_request(q)) != NULL) {
		spin_unlock_irq(q->queue_lock);

		if (rq->cmd_type != REQ_TYPE_FS) {
			rv = -EIO;
			goto skip;
		}

		BUG_ON(sampleblk_dev != rq->rq_disk->private_data);

		pos = blk_rq_pos(rq) * sampleblk_sect_size;
		size = blk_rq_bytes(rq);
		if ((pos + size > sampleblk_dev->size)) {
			pr_crit("sampleblk: Beyond-end write (%llu %zx)\n",
				pos, size);
			rv = -EIO;
			goto skip;
		}

		rq_for_each_segment(bvec, rq, iter) {
			kaddr = kmap(bvec->bv_page);

			rv = sampleblk_handle_io(sampleblk_dev, pos,
				bvec->bv_len, kaddr + bvec->bv_offset,
				rq_data_dir(rq));
			if (rv < 0)
				goto skip;

			pos += bvec->bv_len;
			kunmap(bvec->bv_page);
		}
skip:

		blk_end_request_all(rq, rv);

		spin_lock_irq(q->queue_lock);
	}
}

static int sampleblk_ioctl(struct block_device *bdev, fmode_t mode,
			unsigned command, unsigned long argument)
{
	return 0;
}

static int sampleblk_open(struct block_device *bdev, fmode_t mode)
{
	return 0;
}

static void sampleblk_release(struct gendisk *disk, fmode_t mode)
{
}

static const struct block_device_operations sampleblk_fops = {
	.owner = THIS_MODULE,
	.open = sampleblk_open,
	.release = sampleblk_release,
	.ioctl = sampleblk_ioctl,
};

static int sampleblk_alloc(int minor)
{
	struct gendisk *disk;
	int rv = 0;

	sampleblk_dev = kzalloc(sizeof(struct sampleblk_dev), GFP_KERNEL);
	if (!sampleblk_dev) {
		rv = -ENOMEM;
		goto fail;
	}

	sampleblk_dev->size = sampleblk_sect_size * sampleblk_nsects;
	sampleblk_dev->data = vmalloc(sampleblk_dev->size);
	if (!sampleblk_dev->data) {
		rv = -ENOMEM;
		goto fail_dev;
	}
	sampleblk_dev->minor = minor;

	spin_lock_init(&sampleblk_dev->lock);
	sampleblk_dev->queue = blk_init_queue(sampleblk_request,
	    &sampleblk_dev->lock);
	if (!sampleblk_dev->queue) {
		rv = -ENOMEM;
		goto fail_data;
	}

	disk = alloc_disk(minor);
	if (!disk) {
		rv = -ENOMEM;
		goto fail_queue;
	}
	sampleblk_dev->disk = disk;

	disk->major = sampleblk_major;
	disk->first_minor = minor;
	disk->fops = &sampleblk_fops;
	disk->private_data = sampleblk_dev;
	disk->queue = sampleblk_dev->queue;
	sprintf(disk->disk_name, "sampleblk%d", minor);
	set_capacity(disk, sampleblk_nsects);
	add_disk(disk);

	return 0;

fail_queue:
	blk_cleanup_queue(sampleblk_dev->queue);
fail_data:
	vfree(sampleblk_dev->data);
fail_dev:
	kfree(sampleblk_dev);
fail:
	return rv;
}

static void sampleblk_free(struct sampleblk_dev *sampleblk_dev)
{
	del_gendisk(sampleblk_dev->disk);
	blk_cleanup_queue(sampleblk_dev->queue);
	put_disk(sampleblk_dev->disk);
	vfree(sampleblk_dev->data);
	kfree(sampleblk_dev);
}

static int __init sampleblk_init(void)
{
	int rv = 0;

	sampleblk_major = register_blkdev(0, "sampleblk");
	if (sampleblk_major < 0)
		return sampleblk_major;

	rv = sampleblk_alloc(SAMPLEBLK_MINOR);
	if (rv < 0)
		pr_info("sampleblk: disk allocation failed with %d\n", rv);

	pr_info("sampleblk: module loaded\n");
	return 0;
}

static void __exit sampleblk_exit(void)
{
	sampleblk_free(sampleblk_dev);
	unregister_blkdev(sampleblk_major, "sampleblk");

	pr_info("sampleblk: module unloaded\n");
}

module_init(sampleblk_init);
module_exit(sampleblk_exit);
MODULE_LICENSE("GPL");

